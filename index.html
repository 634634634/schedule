<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>月間予定表</title>
    
    <!-- Flatpickr (日付選択ライブラリ) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <script src="https://cdn.jsdelivr.net/npm/flatpickr/dist/l10n/ja.js"></script>
    <!-- SortableJS (ドラッグ＆ドロップライブラリ) -->
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>

    <style>
        :root {
            --primary-color: #2a9d8f;
            --bg-color: #f4f7f6;
            --border-color: #ddd;
            --text-color: #333;
            --holiday-color: #e0535d;
            --saturday-color: #007bff;
            --secondary-color: #e76f51;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background-color: var(--bg-color);
            margin: 0; padding: 20px 0;
            color: var(--text-color);
            -webkit-text-size-adjust: 100%;
        }

        /* --- カレンダー枠 --- */
        .calendar-container {
            width: 95%; max-width: 1000px; margin: auto;
            background: #fff; border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        /* 編集モード時のスタイル */
        .calendar-container.editing-mode {
            box-shadow: 0 0 0 4px rgba(231, 111, 81, 0.5);
        }
        .calendar-container.editing-mode .calendar-header {
            background-color: var(--secondary-color);
        }
        .calendar-container.editing-mode .day-column {
            pointer-events: auto; /* ドラッグ＆ドロップを有効化 */
            border: 1px dashed var(--secondary-color);
            background-color: rgba(231, 111, 81, 0.1);
            border-radius: 4px;
        }

        /* --- ヘッダー --- */
        .calendar-header {
            display: flex; justify-content: center; align-items: center;
            padding: 15px 20px; background-color: var(--primary-color); color: #fff;
            position: relative;
            transition: background-color 0.3s;
        }
        .header-left {
            position: absolute; left: 20px;
            display: flex; align-items: center;
        }
        .header-right {
            position: absolute; right: 20px;
            display: flex; align-items: center; gap: 10px;
        }
        .calendar-header button {
            background: rgba(255,255,255,0.2); border: none; color: #fff;
            padding: 5px 15px; border-radius: 4px; cursor: pointer; font-size: 1.2em;
        }
        .calendar-header button:hover { background: rgba(255,255,255,0.4); }
        #btn-edit { font-size: 0.9em; }
        #btn-edit.active {
            background: #fff; color: var(--primary-color); font-weight: bold;
        }
        .calendar-container.editing-mode #btn-edit.active {
            color: var(--secondary-color);
        }
        #month-year { font-size: 1.4em; font-weight: bold; margin: 0; }

        /* --- グリッド (New) --- */
        .calendar-grid-header {
            display: grid; grid-template-columns: repeat(7, 1fr);
            background: #f9f9f9; border-bottom: 1px solid var(--border-color);
        }
        .header-cell {
            padding: 10px; text-align: center; font-size: 0.9em; color: #666;
            border-right: 1px solid var(--border-color);
        }
        .week-row {
            position: relative; border-bottom: 1px solid var(--border-color);
            min-height: 120px;
        }
        .week-bg {
            display: grid; grid-template-columns: repeat(7, 1fr);
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0;
        }
        .day-cell-bg {
            border-right: 1px solid var(--border-color); background: #fff;
            transition: background 0.2s; cursor: pointer;
        }
        .day-cell-bg:hover { background-color: #f0f8ff; }
        
        .week-content {
            position: relative; z-index: 1;
            display: grid; grid-template-columns: repeat(7, 1fr);
            pointer-events: none;
            height: 100%;
        }
        .day-column {
            position: relative;
            display: flex; flex-direction: column; gap: 2px;
            padding: 22px 2px 5px 2px; /* 上部は日付数字用に空ける */
            height: 100%; box-sizing: border-box;
        }
        .day-number-container {
            position: absolute; top: 2px; left: 2px; pointer-events: none; z-index: 5;
            right: 2px;
            display: flex; align-items: center;
            justify-content: space-between;
            gap: 2px;
        }
        .day-meta-left {
            display: flex; align-items: center; gap: 2px;
            flex-shrink: 1; overflow: hidden;
        }
        .day-meta-right {
            display: flex; flex-direction: column; align-items: flex-end;
            flex-shrink: 0;
        }
        .day-meta-right.grid-mode {
            display: grid;
            grid-template-columns: repeat(2, auto);
            gap: 0 2px;
        }

        /* --- 日付数字 --- */
        .day-number {
            font-size: 0.75em; display: inline-flex; justify-content: center; align-items: center;
            width: 20px; height: 20px; border-radius: 50%;
            flex-shrink: 0;
        }
        .day-number.holiday { color: var(--holiday-color); }
        .day-number.saturday { color: var(--saturday-color); }
        .day-number.today {
            background-color: var(--primary-color);
            color: #fff !important;
        }
        .holiday-name {
            font-size: 0.6em; color: var(--holiday-color);
            line-height: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            min-width: 0;
        }
        /* --- 吉日 --- */
        .kichijitsu {
            font-size: 0.6em;
            white-space: nowrap;
            line-height: 1.1;
        }
        .kichijitsu.ichimanbai {
            color: #d4af37; /* 金色 */
            font-weight: bold;
        }
        .kichijitsu.tensha {
            color: #e0535d; /* 赤 */
            font-weight: bold;
        }
        .kichijitsu.tora {
            color: #f4a261; /* 虎色(オレンジ) */
            font-weight: bold;
        }
        .kichijitsu.mi {
            color: #2a9d8f; /* 蛇色(青緑) */
            font-weight: bold;
        }
        .kichijitsu.tsuchinoto-mi {
            color: #b8860b; /* 濃い金 */
            font-weight: bold;
        }
        .kichijitsu.fujoju {
            color: #7f8c8d; /* グレー */
        }

        /* --- イベントバー表示 --- */
        .event-bar {
            position: relative; margin: 1px 2px;
            font-size: 0.75em; padding: 2px 4px;
            border-radius: 3px; color: #fff; 
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            cursor: pointer; pointer-events: auto;
            
            /* Wrapping */
            white-space: normal;
            word-break: break-word;
            line-height: 1.2;
        }
        /* 編集モード時のカーソル */
        .calendar-container.editing-mode .event-bar { cursor: grab; }
        .calendar-container.editing-mode .event-bar:active { cursor: grabbing; }

        /* 連結用スタイル */
        .event-bar.is-start { border-top-right-radius: 0; border-bottom-right-radius: 0; margin-right: -2px; z-index: 2; }
        .event-bar.is-end { border-top-left-radius: 0; border-bottom-left-radius: 0; margin-left: -2px; z-index: 2; }
        .event-bar.is-middle { border-radius: 0; margin-left: -2px; margin-right: -2px; z-index: 1; }
        .event-bar.is-single { z-index: 3; }

        /* --- モーダル --- */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); display: none; z-index: 1000;
            justify-content: center; align-items: center;
        }
        .modal-content {
            background: #fff; padding: 25px; border-radius: 8px;
            width: 90%; max-width: 400px; box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .modal-header {
            display: flex; justify-content: space-between; margin-bottom: 20px;
            border-bottom: 1px solid #eee; padding-bottom: 10px;
        }
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; font-size: 0.9em; color: #666; margin-bottom: 5px; }
        .form-group input[type="text"], .form-group input[type="date"], .flatpickr-input {
            width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;
            box-sizing: border-box; font-size: 1em;
        }
        .form-group textarea {
            width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;
            box-sizing: border-box; font-size: 1em; resize: vertical; min-height: 60px;
        }
        
        /* 色選択ラジオボタン */
        .color-picker { display: flex; gap: 10px; }
        .color-option {
            width: 30px; height: 30px; border-radius: 50%; cursor: pointer;
            border: 2px solid transparent; transition: transform 0.2s;
        }
        .color-option:hover { transform: scale(1.1); }
        .color-option.selected {
            border-color: #fff; /* 内側に白枠を表示 */
            box-shadow: 0 0 0 2px #333; /* 外側に黒枠のような影を追加 */
            transform: scale(1.1);
        }

        /* モード切替スイッチ */
        .mode-switch { display: flex; gap: 15px; margin-bottom: 5px; }
        .mode-switch label { display: flex; align-items: center; gap: 5px; cursor: pointer; font-weight: normal; font-size: 0.9em; }

        .modal-footer {
            display: flex; justify-content: space-between; margin-top: 25px;
        }
        .btn {
            padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;
        }
        .btn-save { background: var(--primary-color); color: #fff; }
        .btn-delete { background: #e0535d; color: #fff; }
        .btn-cancel { background: #ccc; color: #333; }

        /* --- ローディング/保存ステータス --- */
        #status-msg {
            position: fixed; top: 10px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); color: #fff; padding: 8px 20px;
            border-radius: 20px; font-size: 0.9em; opacity: 0; transition: opacity 0.3s;
            pointer-events: none; z-index: 2000;
        }
        #status-msg.visible { opacity: 1; }

        /* Flatpickrのカレンダーをモーダルより前面に表示 */
        .flatpickr-calendar { z-index: 2000 !important; }

        /* --- スマホ表示調整 --- */
        @media (max-width: 768px) {
            .kichijitsu { font-size: 0.5em; }
            .day-number { font-size: 0.7em; }
            .holiday-name { font-size: 0.5em; }
        }

    </style>
</head>
<body>

    <div id="status-msg"></div>

    <div class="calendar-container">
        <div class="calendar-header">
            <div class="header-left">
                <button id="prev-month">&lt;</button>
            </div>
            <h2 id="month-year"></h2>
            <div class="header-right">
                <button id="btn-edit">編集</button>
                <button id="next-month">&gt;</button>
            </div>
        </div>
        <div id="calendar-view"></div>
    </div>

    <!-- 編集モーダル -->
    <div id="event-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modal-title">予定の編集</h3>
                <span style="cursor:pointer; font-size:1.5em;" id="modal-close">&times;</span>
            </div>
            
            <div class="form-group">
                <label>タイトル</label>
                <input type="text" id="input-title" placeholder="予定を入力...">
            </div>

            <div class="form-group" id="mode-select-group">
                <label>登録モード</label>
                <div class="mode-switch">
                    <label><input type="radio" name="date-mode" value="range" checked> 期間 (連続)</label>
                    <label><input type="radio" name="date-mode" value="multiple"> 複数日 (個別)</label>
                </div>
            </div>

            <div class="form-group">
                <label>期間</label>
                <input type="text" id="input-range" placeholder="日付を選択..." readonly>
                <input type="hidden" id="input-start">
                <input type="hidden" id="input-end">
            </div>

            <div class="form-group">
                <label>メモ</label>
                <textarea id="input-memo" placeholder="詳細を入力..."></textarea>
            </div>

            <div class="form-group">
                <label>色</label>
                <div class="color-picker" id="color-picker">
                    <!-- JSで生成 -->
                </div>
                <input type="hidden" id="input-color">
            </div>

            <input type="hidden" id="input-id">

            <div class="modal-footer">
                <button class="btn btn-delete" id="btn-delete" style="display:none;">削除</button>
                <div>
                    <button class="btn btn-cancel" id="btn-cancel">キャンセル</button>
                    <button class="btn btn-save" id="btn-save">保存</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- 吉日計算ヘルパー ---
        const Kichijitsu = {
            // 日の干支を求める (1900/1/1 = 甲戌(10) を基準)
            getEto: function(date) {
                const base = new Date(1900, 0, 1);
                const diff = Math.floor((date - base) / (1000 * 60 * 60 * 24));
                let num = (diff + 10) % 60;
                if (num < 0) num += 60;
                return num;
            },
            // 節月を求める (簡易計算: 1=小寒〜, 2=立春〜... 12=大雪〜)
            getSetsuMonth: function(date) {
                const m = date.getMonth() + 1;
                const d = date.getDate();
                // 各月の節入り日(近似値)
                const setsuDays = [6, 4, 6, 5, 6, 6, 7, 8, 8, 8, 7, 7]; 
                let month = m - 1; // 0-11
                if (d < setsuDays[m - 1]) month = (month + 11) % 12;
                return month + 1; // 1-12
            },
            get: function(date) {
                const etoNum = this.getEto(date);
                const shi = etoNum % 12; // 十二支 (0:子, 1:丑...)
                const setsuM = this.getSetsuMonth(date);
                const result = [];

                // 一粒万倍日 (節月ごとの十二支)
                // 1:小寒(12月節) -> 子, 卯 (定義:12月)
                // 2:立春(正月節) -> 丑, 午 (定義:正月)
                // ...
                const ichimanbaiTable = {
                    1: [0, 3],   // 12月節(小寒〜): 子, 卯
                    2: [1, 6],   // 正月節(立春〜): 丑, 午
                    3: [2, 9],   // 2月節(啓蟄〜): 寅, 酉
                    4: [0, 3],   // 3月節(清明〜): 子, 卯
                    5: [3, 4],   // 4月節(立夏〜): 卯, 辰
                    6: [5, 6],   // 5月節(芒種〜): 巳, 午
                    7: [6, 9],   // 6月節(小暑〜): 午, 酉
                    8: [0, 7],   // 7月節(立秋〜): 子, 未
                    9: [3, 8],   // 8月節(白露〜): 卯, 申
                    10: [6, 9],  // 9月節(寒露〜): 午, 酉
                    11: [9, 10], // 10月節(立冬〜): 酉, 戌
                    12: [0, 11]  // 11月節(大雪〜): 子, 亥
                };
                if (ichimanbaiTable[setsuM] && ichimanbaiTable[setsuM].includes(shi)) {
                    result.push({ label: '一粒万倍日', cls: 'ichimanbai' });
                }

                // 天赦日 (季節と干支)
                let isTensha = false;
                if (setsuM >= 2 && setsuM <= 4) { if (etoNum === 14) isTensha = true; } // 春: 戊寅
                else if (setsuM >= 5 && setsuM <= 7) { if (etoNum === 30) isTensha = true; } // 夏: 甲午
                else if (setsuM >= 8 && setsuM <= 10) { if (etoNum === 44) isTensha = true; } // 秋: 戊申
                else { if (etoNum === 0) isTensha = true; } // 冬: 甲子
                if (isTensha) result.push({ label: '天赦日', cls: 'tensha' });

                // 己巳の日 (優先) or 巳の日
                if (etoNum === 5) {
                    result.push({ label: '己巳の日', cls: 'tsuchinoto-mi' });
                } else if (shi === 5) {
                    result.push({ label: '巳の日', cls: 'mi' });
                }

                // 寅の日
                if (shi === 2) {
                    result.push({ label: '寅の日', cls: 'tora' });
                }

                // 不成就日 (Intl.DateTimeFormatを利用した旧暦計算)
                // ブラウザの中国暦(chinese)を利用して旧暦の月日を取得
                try {
                    const formatter = new Intl.DateTimeFormat('ja-JP-u-ca-chinese', { month: 'numeric', day: 'numeric' });
                    const parts = formatter.formatToParts(date);
                    const mPart = parts.find(p => p.type === 'month').value;
                    const dPart = parts.find(p => p.type === 'day').value;
                    
                    const m = parseInt(mPart, 10);
                    const d = parseInt(dPart, 10);
                    
                    // 旧暦月ごとの不成就日開始日 (1月:3日, 2月:2日...)
                    const startDays = { 1:3, 2:2, 3:1, 4:4, 5:5, 6:6, 7:3, 8:2, 9:1, 10:4, 11:5, 12:6 };
                    const start = startDays[m];
                    
                    if (start && (d === start || d === start + 8 || d === start + 16 || d === start + 24)) {
                        result.push({ label: '不成就日', cls: 'fujoju' });
                    }
                } catch (e) {
                    console.error('旧暦計算エラー', e);
                }

                return result;
            }
        };

        // --- API Service ---
        class ApiService {
            constructor(apiUrl) {
                this.apiUrl = apiUrl;
            }

            async fetchHolidays() {
                const res = await fetch('https://holidays-jp.github.io/api/v1/date.json');
                return await res.json();
            }

            async fetchEvents(start, end) {
                const res = await fetch(`${this.apiUrl}?start=${start}&end=${end}`);
                const data = await res.json();
                if (!Array.isArray(data)) throw new Error('Invalid data format');
                return data;
            }

            async postEvent(action, eventData) {
                await fetch(this.apiUrl, {
                    method: 'POST',
                    mode: 'no-cors',
                    headers: { 'Content-Type': 'text/plain' },
                    body: JSON.stringify({ action, event: eventData })
                });
            }
        }

        class CalendarApp {
            constructor() {
                this.config = {
                    // ★ここに新しいGASのURLを貼り付けてください
                    API_URL: 'https://script.google.com/macros/s/AKfycbwhxNwFdD7AQer3TxhHcWeocINGO3ZgWiYB4sig10r483a77GtB6x2CuX0N_YQssXkP/exec',
                    COLORS: ['#e76f51', '#f4a261', '#e9c46a', '#2a9d8f', '#264653', '#007bff', '#6f42c1', '#6c757d']
                };
                
                this.api = new ApiService(this.config.API_URL);
                this.state = {
                    currentDate: new Date(),
                    events: [],
                    holidays: {},
                    initialForm: {}
                };
                
                this.ui = {};
                this.datePicker = null;
                this.currentMode = 'range';
                this.isEditing = false;
                this.sortables = [];
                this.touchStartX = 0;
            }

            init() {
                this.cacheDOM();
                this.initColorPicker();
                this.initDatePicker('range');
                this.bindEvents();
                this.fetchHolidays().then(() => this.renderCalendar());
                this.fetchEvents();
            }

            cacheDOM() {
                this.ui = {
                    monthYear: document.getElementById('month-year'),
                    calendarView: document.getElementById('calendar-view'),
                    modal: document.getElementById('event-modal'),
                    container: document.querySelector('.calendar-container'),
                    status: document.getElementById('status-msg'),
                    inputs: {
                        id: document.getElementById('input-id'),
                        title: document.getElementById('input-title'),
                        start: document.getElementById('input-start'),
                        end: document.getElementById('input-end'),
                        color: document.getElementById('input-color'),
                        memo: document.getElementById('input-memo')
                    },
                    btns: {
                        save: document.getElementById('btn-save'),
                        delete: document.getElementById('btn-delete'),
                        cancel: document.getElementById('btn-cancel'),
                        close: document.getElementById('modal-close'),
                        edit: document.getElementById('btn-edit')
                    }
                };
            }

            initColorPicker() {
                const container = document.getElementById('color-picker');
                this.config.COLORS.forEach((color, index) => {
                    const div = document.createElement('div');
                    div.className = 'color-option';
                    div.style.backgroundColor = color;
                    div.onclick = () => this.selectColor(color, div);
                    if (index === 3) this.selectColor(color, div); // デフォルト選択
                    container.appendChild(div);
                });
            }

            initDatePicker(mode) {
                if (this.datePicker) this.datePicker.destroy();
                this.currentMode = mode;

                this.datePicker = flatpickr("#input-range", {
                    mode: mode,
                    locale: "ja",
                    dateFormat: "Y-m-d",
                    conjunction: mode === 'range' ? " ～ " : ", ",
                    onChange: (selectedDates, dateStr, instance) => {
                        if (mode === 'range' && selectedDates.length > 0) {
                            this.ui.inputs.start.value = this.formatDate(selectedDates[0]);
                            this.ui.inputs.end.value = this.formatDate(selectedDates[1] || selectedDates[0]);
                        }
                    }
                });
            }

            bindEvents() {
                document.getElementById('prev-month').onclick = () => this.changeMonth(-1);
                document.getElementById('next-month').onclick = () => this.changeMonth(1);
                
                this.ui.btns.close.onclick = () => this.confirmAndClose();
                this.ui.btns.cancel.onclick = () => this.confirmAndClose();
                this.ui.modal.onclick = (e) => { if(e.target === this.ui.modal) this.confirmAndClose(); };
                
                this.ui.btns.save.onclick = () => this.saveEvent();
                this.ui.btns.delete.onclick = () => this.deleteEvent();
                
                this.ui.btns.edit.onclick = () => this.toggleEditMode();

                document.querySelectorAll('input[name="date-mode"]').forEach(radio => {
                    radio.onchange = (e) => this.initDatePicker(e.target.value);
                });

                this.ui.calendarView.addEventListener('click', (e) => this.handleCalendarClick(e));
                
                // スワイプ操作
                this.ui.calendarView.addEventListener('touchstart', (e) => {
                    this.touchStartX = e.changedTouches[0].screenX;
                }, { passive: true });
                this.ui.calendarView.addEventListener('touchend', (e) => {
                    this.handleSwipe(e.changedTouches[0].screenX);
                }, { passive: true });
            }

            // --- API Methods ---
            async fetchHolidays() {
                try {
                    this.state.holidays = await this.api.fetchHolidays();
                } catch (e) { console.error('祝日取得失敗', e); }
            }

            async fetchEvents() {
                this.showStatus('読み込み中...');
                const y = this.state.currentDate.getFullYear();
                const m = this.state.currentDate.getMonth();
                const start = this.formatDate(new Date(y, m - 1, 20));
                const end = this.formatDate(new Date(y, m + 1, 15));

                try {
                    const newEvents = await this.api.fetchEvents(start, end);
                    
                    this.state.events = this.state.events.filter(e => e.start > end || e.end < start);
                    this.state.events = this.state.events.concat(newEvents);
                    
                    this.renderCalendar();
                    this.showStatus('完了', 1000);
                } catch (e) {
                    this.showStatus('エラー発生', 3000);
                    console.error(e);
                }
            }

            async postEvent(action, eventData, silent = false) {
                if (!silent) this.showStatus('クラウドに保存中...');
                try {
                    await this.api.postEvent(action, eventData);
                    if (!silent) this.showStatus('保存完了', 2000);
                } catch (e) {
                    if (!silent) this.showStatus('保存失敗', 3000);
                }
            }

            // --- Logic & UI Methods ---
            handleCalendarClick(e) {
                // イベントバーがクリックされた場合
                const eventBar = e.target.closest('.event-bar');
                if (eventBar) {
                    if (this.isEditing) return;
                    const eventId = eventBar.dataset.eventId;
                    const event = this.state.events.find(e => e.id === eventId);
                    if (event) this.openModal(event);
                    return;
                }

                // 日付セル（背景）がクリックされた場合
                const dayCell = e.target.closest('.day-cell-bg');
                if (dayCell) {
                    const dateStr = dayCell.dataset.date;
                    if (dateStr) this.openModal({ start: dateStr, end: dateStr });
                }
            }

            handleSwipe(endX) {
                if (this.isEditing) return; // 編集モード中は誤操作防止のため無効化
                const threshold = 50;
                if (endX < this.touchStartX - threshold) this.changeMonth(1); // 左スワイプ（進む）
                if (endX > this.touchStartX + threshold) this.changeMonth(-1); // 右スワイプ（戻る）
            }

            toggleEditMode() {
                this.isEditing = !this.isEditing;
                this.ui.btns.edit.classList.toggle('active', this.isEditing);
                this.ui.container.classList.toggle('editing-mode', this.isEditing);
                
                if (this.isEditing) {
                    this.initSortables();
                    this.showStatus('ドラッグで日付を移動できます', 2000);
                } else {
                    this.destroySortables();
                }
            }

            initSortables() {
                this.destroySortables();
                const columns = document.querySelectorAll('.day-column');
                columns.forEach(col => {
                    const sortable = new Sortable(col, {
                        group: 'calendar-events',
                        animation: 150,
                        draggable: '.event-bar',
                        onEnd: (evt) => this.handleDrop(evt)
                    });
                    this.sortables.push(sortable);
                });
            }

            destroySortables() {
                this.sortables.forEach(s => s.destroy());
                this.sortables = [];
            }

            async handleDrop(evt) {
                const eventId = evt.item.dataset.eventId;
                const oldDateStr = evt.from.dataset.date;
                const newDateStr = evt.to.dataset.date;

                const movedEvent = this.state.events.find(e => e.id === eventId);
                if (!movedEvent) return;

                // 1. 日付の更新（移動があった場合）
                if (oldDateStr !== newDateStr) {
                    const diffTime = new Date(newDateStr) - new Date(oldDateStr);
                    const diffDays = diffTime / (1000 * 60 * 60 * 24);

                    const s = new Date(movedEvent.start);
                    const e = new Date(movedEvent.end);
                    s.setDate(s.getDate() + diffDays);
                    e.setDate(e.getDate() + diffDays);
                    
                    movedEvent.start = this.formatDate(s);
                    movedEvent.end = this.formatDate(e);
                }

                // 2. 並び順の更新（移動先の全イベントを再インデックス）
                const newOrderIds = Array.from(evt.to.querySelectorAll('.event-bar')).map(el => el.dataset.eventId);
                const eventsToUpdate = [];
                
                // 日付変更があった場合は必ず保存対象にする
                if (oldDateStr !== newDateStr) eventsToUpdate.push(movedEvent);

                newOrderIds.forEach((id, index) => {
                    const ev = this.state.events.find(e => e.id === id);
                    if (ev) {
                        if (ev.order !== index) {
                            ev.order = index;
                            if (!eventsToUpdate.includes(ev)) eventsToUpdate.push(ev);
                        }
                    }
                });

                // 3. 保存と再描画
                this.renderCalendar();
                
                if (eventsToUpdate.length > 0) {
                    this.showStatus(`${eventsToUpdate.length}件を保存中...`);
                    try {
                        await Promise.all(eventsToUpdate.map(ev => this.api.postEvent('upsert', ev)));
                        this.showStatus('保存完了', 2000);
                    } catch (e) {
                        this.showStatus('保存失敗', 3000);
                    }
                }
            }

            changeMonth(diff) {
                this.state.currentDate.setMonth(this.state.currentDate.getMonth() + diff);
                this.renderCalendar();
                this.fetchEvents();
            }

            renderCalendar() {
                const y = this.state.currentDate.getFullYear();
                const m = this.state.currentDate.getMonth();
                this.ui.monthYear.textContent = `${y}年 ${m + 1}月`;
                
                const container = this.ui.calendarView;
                container.innerHTML = '';

                this.renderHeader(container);
                this.renderWeeks(container, y, m);
                
                if (this.isEditing) this.initSortables(); // 再描画後もSortableを適用
            }

            renderHeader(container) {
                const header = document.createElement('div');
                header.className = 'calendar-grid-header';
                ['日','月','火','水','木','金','土'].forEach((d, i) => {
                    const cell = document.createElement('div');
                    cell.className = 'header-cell';
                    cell.textContent = d;
                    if(i===0) cell.style.color = 'var(--holiday-color)';
                    if(i===6) cell.style.color = 'var(--saturday-color)';
                    header.appendChild(cell);
                });
                container.appendChild(header);
            }

            renderWeeks(container, y, m) {
                const firstDay = new Date(y, m, 1);
                const lastDay = new Date(y, m + 1, 0);
                const todayStr = this.formatDate(new Date());
                
                let current = new Date(firstDay);
                current.setDate(1 - current.getDay());

                for (let row = 0; row < 6; row++) {
                    const weekRow = document.createElement('div');
                    weekRow.className = 'week-row';
                    
                    const weekBg = document.createElement('div');
                    weekBg.className = 'week-bg';
                    
                    const weekContent = document.createElement('div');
                    weekContent.className = 'week-content';

                    for (let col = 0; col < 7; col++) {
                        this.renderDay(current, m, todayStr, col, weekBg, weekContent);
                        current.setDate(current.getDate() + 1);
                    }

                    weekRow.appendChild(weekBg);
                    weekRow.appendChild(weekContent);
                    container.appendChild(weekRow);

                    if (current > lastDay && current.getDay() === 0) break;
                }
            }

            renderDay(current, m, todayStr, col, weekBg, weekContent) {
                const dateStr = this.formatDate(current);
                
                // Background Cell
                const bgCell = document.createElement('div');
                bgCell.className = 'day-cell-bg';
                if (current.getMonth() !== m) bgCell.style.backgroundColor = '#f9f9f9';
                bgCell.dataset.date = dateStr; // イベント委譲用にデータを埋め込む
                weekBg.appendChild(bgCell);

                // Day Column
                const dayColumn = document.createElement('div');
                dayColumn.className = 'day-column';
                dayColumn.dataset.date = dateStr; // ドラッグ用

                // Day Number
                const dayNum = current.getDate();
                const isHoliday = this.state.holidays[dateStr];
                let dayClass = col === 0 ? 'holiday' : (col === 6 ? 'saturday' : (isHoliday ? 'holiday' : ''));
                if (dateStr === todayStr) dayClass += ' today';
                
                // 吉日計算
                const kichijitsuList = Kichijitsu.get(current);
                
                // 3つ以上ある場合は短縮表記にして2列表示
                let isGridMode = false;
                if (kichijitsuList.length >= 3) {
                    isGridMode = true;
                    const abbrMap = {
                        '一粒万倍日': '一粒',
                        '天赦日': '天赦',
                        '寅の日': '寅',
                        '巳の日': '巳',
                        '己巳の日': '己巳',
                        '不成就日': '不成就'
                    };
                    kichijitsuList.forEach(k => { if (abbrMap[k.label]) k.label = abbrMap[k.label]; });
                }

                const kichijitsuHtml = kichijitsuList.map(k => {
                    return `<span class="kichijitsu ${k.cls}">${k.label}</span>`;
                }).join('');

                const numDiv = document.createElement('div');
                numDiv.className = 'day-number-container';
                const rightClass = isGridMode ? 'day-meta-right grid-mode' : 'day-meta-right';
                numDiv.innerHTML = `<div class="day-meta-left"><span class="day-number ${dayClass}">${dayNum}</span>${isHoliday ? `<span class="holiday-name">${this.state.holidays[dateStr]}</span>` : ''}</div><div class="${rightClass}">${kichijitsuHtml}</div>`;
                dayColumn.appendChild(numDiv);

                this.renderEvents(dayColumn, dateStr);

                weekContent.appendChild(dayColumn);
            }

            renderEvents(container, dateStr) {
                const dayEvents = this.state.events.filter(e => e.start <= dateStr && e.end >= dateStr);
                dayEvents.sort((a, b) => {
                    // orderによるソートを優先
                    if (a.order !== undefined || b.order !== undefined) {
                        const orderA = a.order !== undefined ? a.order : 9999;
                        const orderB = b.order !== undefined ? b.order : 9999;
                        if (orderA !== orderB) return orderA - orderB;
                    }

                    const durA = (new Date(a.end) - new Date(a.start));
                    const durB = (new Date(b.end) - new Date(b.start));
                    if (durA !== durB) return durB - durA;
                    return a.start.localeCompare(b.start);
                });

                dayEvents.forEach(evt => {
                    const div = document.createElement('div');
                    div.className = 'event-bar';
                    div.textContent = evt.title;
                    div.style.backgroundColor = evt.color;
                    div.style.color = this.getTextColorForBackground(evt.color);
                    div.dataset.eventId = evt.id; // ドラッグ用

                    if (evt.start < dateStr && evt.end > dateStr) div.classList.add('is-middle');
                    else if (evt.start === dateStr && evt.end > dateStr) div.classList.add('is-start');
                    else if (evt.start < dateStr && evt.end === dateStr) div.classList.add('is-end');
                    else div.classList.add('is-single');

                    container.appendChild(div);
                });
            }

            openModal(eventData = {}) {
                const isEdit = !!eventData.id;
                
                let dateText = '';
                if (eventData.start) {
                    const [y, m, d] = eventData.start.split('-').map(Number);
                    const holiday = this.state.holidays[eventData.start];
                    dateText = `${m}/${d}`;
                    if (holiday) dateText += ` ${holiday}`;
                }

                const titleText = isEdit ? '予定の編集' : '新しい予定';
                const titleEl = document.getElementById('modal-title');
                titleEl.innerHTML = dateText ? `<div style="font-size:0.7em; color:#666; font-weight:normal; margin-bottom:2px;">${dateText}</div>${titleText}` : titleText;
                
                const modeGroup = document.getElementById('mode-select-group');
                if (isEdit) {
                    modeGroup.style.display = 'none';
                    this.initDatePicker('range');
                } else {
                    modeGroup.style.display = 'block';
                    document.querySelector('input[value="range"]').checked = true;
                    this.initDatePicker('range');
                }

                this.ui.inputs.id.value = eventData.id || this.generateUUID();
                this.ui.inputs.title.value = eventData.title || '';
                this.ui.inputs.start.value = eventData.start || '';
                this.ui.inputs.end.value = eventData.end || eventData.start || '';
                this.ui.inputs.memo.value = eventData.memo || '';
                
                this.datePicker.setDate([this.ui.inputs.start.value, this.ui.inputs.end.value]);
                this.selectColor(eventData.color || this.config.COLORS[3]);

                this.ui.btns.delete.style.display = isEdit ? 'block' : 'none';
                this.ui.modal.style.display = 'flex';
                
                this.state.initialForm = {
                    title: this.ui.inputs.title.value,
                    start: this.ui.inputs.start.value,
                    end: this.ui.inputs.end.value,
                    color: this.ui.inputs.color.value,
                    memo: this.ui.inputs.memo.value
                };
            }

            closeModal() {
                this.ui.modal.style.display = 'none';
            }

            confirmAndClose() {
                const current = {
                    title: this.ui.inputs.title.value,
                    start: this.ui.inputs.start.value,
                    end: this.ui.inputs.end.value,
                    color: this.ui.inputs.color.value,
                    memo: this.ui.inputs.memo.value
                };
                
                if (JSON.stringify(this.state.initialForm) !== JSON.stringify(current)) {
                    if (!confirm('変更が保存されていません。\n破棄して閉じますか？')) return;
                }
                this.closeModal();
            }

            async saveEvent() {
                if (this.currentMode === 'multiple') {
                    await this.saveMultipleEvents();
                } else {
                    await this.saveSingleEvent();
                }
            }

            async saveMultipleEvents() {
                const dates = this.datePicker.selectedDates;
                if (dates.length === 0) { alert('日付を選択してください'); return; }
                if (!this.ui.inputs.title.value) { alert('タイトルは必須です'); return; }

                const baseData = {
                    title: this.ui.inputs.title.value,
                    color: this.ui.inputs.color.value,
                    memo: this.ui.inputs.memo.value
                };

                const newEvents = dates.map(d => ({
                    ...baseData,
                    id: this.generateUUID(),
                    start: this.formatDate(d),
                    end: this.formatDate(d)
                }));

                this.state.events.push(...newEvents);
                this.renderCalendar();
                this.state.initialForm = {};
                this.closeModal();

                this.showStatus('一括保存中...');
                newEvents.forEach(evt => this.postEvent('upsert', evt, true));
            }

            async saveSingleEvent() {
                const data = {
                    id: this.ui.inputs.id.value,
                    title: this.ui.inputs.title.value,
                    start: this.ui.inputs.start.value,
                    end: this.ui.inputs.end.value,
                    color: this.ui.inputs.color.value,
                    memo: this.ui.inputs.memo.value
                };

                if (!data.title || !data.start) { alert('タイトルと開始日は必須です'); return; }
                if (data.start > data.end) { alert('終了日は開始日より後にしてください'); return; }

                const idx = this.state.events.findIndex(e => e.id === data.id);
                if (idx > -1) this.state.events[idx] = { ...this.state.events[idx], ...data };
                else this.state.events.push(data);

                this.renderCalendar();
                this.state.initialForm = {};
                this.closeModal();

                this.postEvent('upsert', data);
            }

            deleteEvent() {
                if (!confirm('本当に削除しますか？')) return;
                const id = this.ui.inputs.id.value;
                this.state.events = this.state.events.filter(e => e.id !== id);
                this.renderCalendar();
                this.closeModal();
                this.postEvent('delete', { id: id });
            }

            // --- Utils ---
            selectColor(color, element) {
                this.ui.inputs.color.value = color;
                document.querySelectorAll('.color-option').forEach(el => el.classList.remove('selected'));
                if (element) element.classList.add('selected');
                else {
                    const target = Array.from(document.querySelectorAll('.color-option'))
                        .find(el => el.style.backgroundColor === color || this.rgbToHex(el.style.backgroundColor) === color);
                    if (target) target.classList.add('selected');
                }
            }

            rgbToHex(rgb) {
                if (!rgb.startsWith('rgb')) return rgb;
                const [r, g, b] = rgb.match(/\d+/g);
                return "#" + ((1 << 24) + (+r << 16) + (+g << 8) + +b).toString(16).slice(1);
            }

            getTextColorForBackground(hex) {
                if (!hex) return '#fff';
                if (hex.startsWith('#')) hex = hex.slice(1);
                if (hex.length === 3) hex = hex.split('').map(c => c + c).join('');
                const r = parseInt(hex.substring(0, 2), 16);
                const g = parseInt(hex.substring(2, 4), 16);
                const b = parseInt(hex.substring(4, 6), 16);
                const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
                return (yiq >= 128) ? '#333' : '#fff';
            }

            formatDate(d) {
                return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
            }

            generateUUID() {
                if (typeof crypto !== 'undefined' && crypto.randomUUID) {
                    return crypto.randomUUID();
                }
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
                    const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
            }

            showStatus(msg, duration) {
                this.ui.status.textContent = msg;
                this.ui.status.classList.add('visible');
                if (duration) setTimeout(() => this.ui.status.classList.remove('visible'), duration);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new CalendarApp().init();
        });
    </script>
</body>
</html>
